// Generated by CoffeeScript 1.3.3
(function() {
  var Alt, AltCommand, Command, CommandFactory, Config, Diagram, ElseCommand, EndCommand, Execution, ExecutionCommand, ExecutionEnd, ExecutionStart, Fragment, FragmentBase, Guard, Item, LifeLine, Message, MessageCommand, Note, NoteCommand, OptionCommand, ReplyMessage, SeqJs, SequenceDiagram, State, SyncMessage, TextParser, Util, View, ViewGroup,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Util = {
    measureTextHeight: function() {
      var body;
      if (!this.span) {
        this.span = document.createElement("span");
        this.span.textContent = "gM";
        this.span.style.visibility = "hidden";
        this.span.style.position = "absolute";
        body = document.body;
        body.insertBefore(this.span, body.firstChild);
      }
      return this.span.offsetHeight / 2;
    },
    trim: function(text) {
      return text.replace(/^\s+|\s+$/g, "");
    }
  };

  Config = {
    margin: 8,
    itemMargin: 20,
    lineMinWidth: 64,
    lineHeight: 32,
    padding: 4,
    executionWidth: 8,
    arrowSize: 8,
    curveSize: 12,
    fragmentMargin: 5,
    textColor: 'rgb(0, 0, 0)',
    strokeColor: 'rgb(0, 0, 0)',
    boxBackgroundColor: 'rgb(255, 255, 255)',
    textBackgroundColor: 'rgba(255, 255, 255, 0.8)'
  };

  View = (function() {

    function View() {
      this.x = 0;
      this.y = 0;
    }

    View.prototype.draw = function(context) {
      context.save();
      this.translate(context);
      this.onDraw(context);
      this.dispatchDraw(context);
      return context.restore();
    };

    View.prototype.translate = function(context) {
      return context.translate(this.x, this.y);
    };

    View.prototype.onDraw = function(context) {};

    View.prototype.dispatchDraw = function(context) {};

    return View;

  })();

  ViewGroup = (function(_super) {

    __extends(ViewGroup, _super);

    function ViewGroup() {
      ViewGroup.__super__.constructor.call(this);
      this.children = [];
    }

    ViewGroup.prototype.dispatchDraw = function(context) {
      var child, _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(child.draw(context));
      }
      return _results;
    };

    ViewGroup.prototype.add = function(child) {
      return this.children.push(child);
    };

    return ViewGroup;

  })(View);

  Diagram = (function(_super) {

    __extends(Diagram, _super);

    function Diagram(context) {
      this.context = context;
      Diagram.__super__.constructor.call(this);
    }

    Diagram.prototype.measureTextWidth = function(text) {
      return this.context.measureText(text).width;
    };

    Diagram.prototype.show = function() {
      this.layout();
      this.context.save();
      this.context.translate(0.5, 0.5);
      this.draw(this.context);
      return this.context.restore();
    };

    Diagram.prototype.layout = function() {};

    Diagram.prototype.drawBoxBasedCenter = function(centerX, topY, minWidth, height, text) {
      var textWidth, width;
      textWidth = this.measureTextWidth(text);
      width = Math.max(textWidth + Config.padding * 2, minWidth);
      this.context.strokeStyle = Config.strokeColor;
      this.context.fillStyle = Config.textBackgroundColor;
      this.context.strokeRect(-width / 2, topY, width, height);
      this.context.fillStyle = Config.textColor;
      return this.context.fillText(text, -textWidth / 2, height / 2 + Util.measureTextHeight() / 2);
    };

    Diagram.prototype.drawBoxBasedRight = function(right, y, text) {
      var width;
      width = this.measureTextWidth(text + Config.padding * 2);
      return this.drawBoxBasedLeft(right - width, y, text);
    };

    Diagram.prototype.drawBoxBasedLeft = function(left, y, text) {
      var height, width;
      height = Util.measureTextHeight();
      width = this.measureTextWidth(text + Config.padding * 2);
      this.context.strokeStyle = Config.strokeColor;
      this.context.fillStyle = Config.textBackgroundColor;
      this.context.beginPath();
      this.context.rect(left, y, width, height + Config.padding * 2);
      this.context.fill();
      this.context.stroke();
      if (text) {
        this.context.fillStyle = Config.textColor;
        return this.context.fillText(text, left + Config.padding, y + height + Config.padding);
      }
    };

    Diagram.prototype.drawText = function(left, y, text) {
      var textHeight, width;
      width = this.measureTextWidth(text) + 1;
      textHeight = Util.measureTextHeight();
      this.context.fillStyle = Config.textBackgroundColor;
      this.context.fillRect(left - 2, y - textHeight + 2, width + 2, textHeight);
      this.context.fillStyle = Config.textColor;
      return this.context.fillText(text, left, y);
    };

    Diagram.prototype.drawTextBasedCenter = function(centerX, bottomY, text) {
      var width;
      width = this.measureTextWidth(text) + 2;
      return this.drawText(centerX - width / 2, bottomY, text);
    };

    Diagram.prototype.drawLine = function(fromX, fromY, toX, toY) {
      this.context.beginPath();
      this.context.moveTo(fromX, fromY);
      this.context.lineTo(toX, toY);
      return this.context.stroke();
    };

    Diagram.prototype.drawArrow = function(fromX, fromY, toX, toY) {
      var arrowSize, wingTailX, wingTailY;
      arrowSize = Config.arrowSize;
      if (fromX > toX) {
        arrowSize = -arrowSize;
      }
      wingTailX = toX - arrowSize;
      wingTailY = arrowSize / 2;
      this.context.beginPath();
      this.context.moveTo(fromX, fromY);
      this.context.lineTo(toX, toY);
      this.context.moveTo(wingTailX, toY + wingTailY);
      this.context.lineTo(toX, toY);
      this.context.lineTo(wingTailX, toY - wingTailY);
      return this.context.stroke();
    };

    return Diagram;

  })(ViewGroup);

  SequenceDiagram = (function(_super) {

    __extends(SequenceDiagram, _super);

    function SequenceDiagram(context) {
      SequenceDiagram.__super__.constructor.call(this, context);
      this.lines = [];
      this.items = [];
      this.fragmentStack = [];
      this.fragmentMaxStack = 0;
      this.x = Config.margin;
      this.y = Config.margin;
      this.bottom = 0;
      this.right = 0;
    }

    SequenceDiagram.prototype.layout = function() {
      this.layoutLifeLines();
      return this.layoutItems();
    };

    SequenceDiagram.prototype.layoutLifeLines = function() {
      var line, right, _i, _len, _ref, _results;
      right = 0;
      _ref = this.lines;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        line.layout(right);
        _results.push(right += line.width + Config.margin);
      }
      return _results;
    };

    SequenceDiagram.prototype.layoutItems = function() {
      var bottom, item, last, lineMargin, _i, _len, _ref;
      bottom = Config.lineHeight;
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.y = bottom + Config.itemMargin;
        item.layout();
        bottom = item.bottom;
      }
      this.bottom = bottom + Config.itemMargin;
      lineMargin = this.fragmentMaxStack * Config.fragmentMargin;
      this.shiftLifeLine(lineMargin);
      if (this.lines.length === 0) {
        return;
      }
      last = this.lines[this.lines.length - 1];
      return this.right = last.x + last.width + lineMargin;
    };

    SequenceDiagram.prototype.addLine = function(lifeLine) {
      this.lines.push(lifeLine);
      return this.add(lifeLine);
    };

    SequenceDiagram.prototype.addItem = function(item) {
      this.items.push(item);
      return this.add(item);
    };

    SequenceDiagram.prototype.pushFragment = function(fragment) {
      this.fragmentStack.push(fragment);
      return this.fragmentMaxStack = Math.max(this.fragmentMaxStack, this.fragmentStack.length);
    };

    SequenceDiagram.prototype.popFragment = function() {
      return this.fragmentStack.pop();
    };

    SequenceDiagram.prototype.shiftLifeLine = function(shiftValue) {
      var line, _i, _len, _ref, _results;
      _ref = this.lines;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(line.x += shiftValue);
      }
      return _results;
    };

    return SequenceDiagram;

  })(Diagram);

  LifeLine = (function(_super) {

    __extends(LifeLine, _super);

    function LifeLine(diagram, name) {
      this.diagram = diagram;
      this.name = name;
      LifeLine.__super__.constructor.call(this);
      this.position = 0;
      this.stack = [];
    }

    LifeLine.prototype.measureWidth = function() {
      this.textWidth = this.diagram.measureTextWidth(this.name);
      return this.width = Math.max(this.textWidth + Config.padding * 2, Config.lineMinWidth);
    };

    LifeLine.prototype.onDraw = function(context) {
      this.diagram.drawBoxBasedCenter(0, 0, Config.lineMinWidth, Config.lineHeight, this.name);
      return this.diagram.drawLine(0, Config.lineHeight, 0, this.end || this.diagram.bottom);
    };

    LifeLine.prototype.startExecution = function(message) {
      var execution;
      execution = new Execution(this.diagram, this.stack.length);
      execution.start = message;
      this.stack.push(execution);
      execution.parent = this;
      return this.add(execution);
    };

    LifeLine.prototype.endExecution = function(message) {
      var execution;
      execution = this.stack.pop();
      return execution.end = message;
    };

    LifeLine.prototype.currentExecution = function() {
      if (this.stack.length === 0) {
        return null;
      } else {
        return this.stack[this.stack.length - 1];
      }
    };

    LifeLine.prototype.layout = function(current) {
      this.measureWidth();
      return this.x = current + this.width / 2;
    };

    return LifeLine;

  })(ViewGroup);

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.layout = function() {
      return this.bottom = this.y;
    };

    Item.prototype.getAbsoluteBottom = function() {
      var _ref;
      return this.bottom + (((_ref = this.parent) != null ? _ref.getAbsoluteTop() : void 0) || 0);
    };

    Item.prototype.getAbsoluteTop = function() {
      var _ref;
      return this.y + (((_ref = this.parent) != null ? _ref.getAbsoluteTop() : void 0) || 0);
    };

    return Item;

  })(ViewGroup);

  Message = (function(_super) {

    __extends(Message, _super);

    function Message(diagram, text, from, to) {
      this.diagram = diagram;
      this.text = text;
      this.from = from;
      this.to = to;
      Message.__super__.constructor.call(this);
      this.textWidth = this.diagram.measureTextWidth(this.text);
    }

    Message.prototype.onDraw = function(context) {
      var from, to;
      from = this.from.x + (this.fromAdjust || 0);
      to = this.to.x + (this.toAdjust || 0);
      if (this.from === this.to) {
        this.drawCurveArrow(context, from, to);
        this.drawCurveText(context, from);
        return;
      }
      this.toRight = from < to;
      this.drawArrow(context, from, to);
      if (this.text != null) {
        return this.drawText(context, from, to);
      }
    };

    Message.prototype.drawArrow = function(context, from, to) {
      return this.diagram.drawArrow(from, 0, to, 0);
    };

    Message.prototype.drawCurveArrow = function(context, from, to) {
      var right;
      right = Math.min(from, to) + Config.curveSize * 2;
      this.diagram.drawLine(from, 0, right, 0);
      this.diagram.drawLine(right, 0, right, Config.curveSize);
      return this.diagram.drawArrow(right, Config.curveSize, to, Config.curveSize);
    };

    Message.prototype.drawText = function(context, from, to) {
      var base;
      base = this.toRight ? from : to;
      return this.diagram.drawTextBasedCenter(base + Math.abs(to - from) / 2, -Config.padding, this.text);
    };

    Message.prototype.drawCurveText = function(context, from) {
      return this.diagram.drawText(from + Config.padding, -Config.padding, this.text);
    };

    Message.prototype.layout = function() {
      this.execution();
      return this.bottom = this.from === this.to ? this.y + Config.curveSize : this.y;
    };

    Message.prototype.execution = function() {
      this.adjustFrom();
      return this.adjustTo();
    };

    Message.prototype.adjustFrom = function() {
      var current;
      current = this.from.currentExecution();
      if (!current) {
        return;
      }
      return this.fromAdjust = this.from.x <= this.to.x ? current.right() : current.left();
    };

    Message.prototype.adjustTo = function() {
      var current;
      current = this.to.currentExecution();
      if (!current) {
        return;
      }
      return this.toAdjust = this.from.x < this.to.x ? current.left() : current.right();
    };

    return Message;

  })(Item);

  SyncMessage = (function(_super) {

    __extends(SyncMessage, _super);

    function SyncMessage(diagram, text, from, to) {
      SyncMessage.__super__.constructor.call(this, diagram, text, from, to);
    }

    SyncMessage.prototype.execution = function() {
      this.adjustFrom();
      this.to.startExecution(this);
      return this.adjustTo();
    };

    return SyncMessage;

  })(Message);

  ReplyMessage = (function(_super) {

    __extends(ReplyMessage, _super);

    function ReplyMessage(diagram, text, from, to) {
      ReplyMessage.__super__.constructor.call(this, diagram, text, from, to);
    }

    ReplyMessage.prototype.execution = function() {
      this.adjustFrom();
      this.from.endExecution(this);
      return this.adjustTo();
    };

    return ReplyMessage;

  })(Message);

  Execution = (function(_super) {

    __extends(Execution, _super);

    function Execution(diagram, overlap) {
      this.diagram = diagram;
      this.overlap = overlap;
      Execution.__super__.constructor.call(this);
      this.start = null;
      this.end = null;
    }

    Execution.prototype.onDraw = function(context) {
      var end, _ref;
      context.strokeStyle = Config.strokeColor;
      context.fillStyle = Config.boxBackgroundColor;
      context.beginPath();
      end = ((_ref = this.end) != null ? _ref.getAbsoluteTop() : void 0) || this.diagram.bottom;
      context.rect(this.left(), this.start.getAbsoluteBottom(), Config.executionWidth, end - this.start.getAbsoluteBottom());
      context.fill();
      return context.stroke();
    };

    Execution.prototype.left = function() {
      return -Config.executionWidth / 2 + Config.executionWidth * this.overlap;
    };

    Execution.prototype.right = function() {
      return Config.executionWidth / 2 + Config.executionWidth * this.overlap;
    };

    return Execution;

  })(View);

  ExecutionStart = (function(_super) {

    __extends(ExecutionStart, _super);

    function ExecutionStart(target) {
      this.target = target;
      ExecutionStart.__super__.constructor.call(this);
    }

    ExecutionStart.prototype.layout = function() {
      ExecutionStart.__super__.layout.call(this);
      return this.execution();
    };

    ExecutionStart.prototype.execution = function() {
      return this.target.startExecution(this);
    };

    return ExecutionStart;

  })(Item);

  ExecutionEnd = (function(_super) {

    __extends(ExecutionEnd, _super);

    function ExecutionEnd(target) {
      this.target = target;
      ExecutionEnd.__super__.constructor.call(this);
    }

    ExecutionEnd.prototype.layout = function() {
      ExecutionEnd.__super__.layout.call(this);
      return this.execution();
    };

    ExecutionEnd.prototype.execution = function() {
      return this.target.endExecution(this);
    };

    return ExecutionEnd;

  })(Item);

  Note = (function(_super) {

    __extends(Note, _super);

    function Note(diagram, text, target, isLeft) {
      this.diagram = diagram;
      this.text = text;
      this.target = target;
      this.isLeft = isLeft;
      Note.__super__.constructor.call(this);
      this.textWidth = this.diagram.measureTextWidth(this.text);
      this.adjustPosition = 0;
    }

    Note.prototype.onDraw = function(context) {
      if (this.isLeft) {
        return this.diagram.drawBoxBasedRight(this.target.x - this.adjustPosition - Config.padding, 0, this.text);
      } else {
        return this.diagram.drawBoxBasedLeft(this.target.x + this.adjustPosition + Config.padding, 0, this.text);
      }
    };

    Note.prototype.adjust = function() {
      var current;
      if (this.isLeft) {
        if (this.target.currentExecution()) {
          return this.adjustPosition += Config.executionWidth / 2;
        }
      } else {
        current = this.target.currentExecution();
        if (current) {
          return this.adjustPosition = current.right();
        }
      }
    };

    Note.prototype.layout = function() {
      this.adjust();
      return this.bottom = this.y + Util.measureTextHeight() + Config.padding * 2;
    };

    return Note;

  })(Item);

  Alt = (function(_super) {

    __extends(Alt, _super);

    function Alt(diagram, text) {
      this.diagram = diagram;
      this.text = text;
      Alt.__super__.constructor.call(this);
      this.textWidth = this.diagram.measureTextWidth(this.text);
      this.textBoxWidth = this.textWidth + Config.padding * 2;
    }

    Alt.prototype.layout = function() {
      var current, item, _i, _len, _ref;
      current = 0;
      this.margin = this.diagram.fragmentStack.length * Config.fragmentMargin;
      this.diagram.pushFragment(this);
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.y = current;
        item.layout();
        current = item.bottom;
      }
      this.diagram.popFragment();
      return this.bottom = this.y + current;
    };

    Alt.prototype.onDraw = function(context) {
      return this.diagram.drawBoxBasedLeft(this.margin, 0, this.text);
    };

    Alt.prototype.addItem = function(item) {
      item.parent = this;
      return this.add(item);
    };

    return Alt;

  })(Item);

  FragmentBase = (function(_super) {

    __extends(FragmentBase, _super);

    function FragmentBase(diagram) {
      this.diagram = diagram;
      FragmentBase.__super__.constructor.call(this);
    }

    FragmentBase.prototype.layout = function() {
      var bottom, item, _i, _len, _ref;
      bottom = Config.itemMargin;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.y = bottom + Config.itemMargin;
        item.layout();
        bottom = item.bottom;
      }
      return this.bottom = this.y + bottom + Config.itemMargin;
    };

    FragmentBase.prototype.onDraw = function(context) {
      context.strokeStyle = Config.strokeColor;
      context.beginPath();
      context.rect(this.margin, 0, this.diagram.right - this.margin * 2, this.bottom - this.y);
      return context.stroke();
    };

    FragmentBase.prototype.addItem = function(item) {
      item.parent = this;
      return this.add(item);
    };

    return FragmentBase;

  })(Item);

  Guard = (function(_super) {

    __extends(Guard, _super);

    function Guard(diagram, text) {
      Guard.__super__.constructor.call(this, diagram);
      this.text = '[ ' + text + ' ]';
      this.textWidth = this.diagram.measureTextWidth(this.text);
    }

    Guard.prototype.onDraw = function(context) {
      var textHeight;
      this.margin = this.parent.margin;
      Guard.__super__.onDraw.call(this, context);
      textHeight = Util.measureTextHeight();
      return this.diagram.drawText(this.margin + this.parent.textBoxWidth + Config.padding, textHeight + Config.padding, this.text);
    };

    return Guard;

  })(FragmentBase);

  Fragment = (function(_super) {

    __extends(Fragment, _super);

    function Fragment(diagram, text) {
      this.text = text;
      Fragment.__super__.constructor.call(this, diagram);
      this.textWidth = this.diagram.measureTextWidth(this.text);
      this.textBoxWidth = this.textWidth + Config.padding * 2;
    }

    Fragment.prototype.layout = function() {
      this.margin = this.diagram.fragmentStack.length * Config.fragmentMargin;
      this.diagram.pushFragment(this);
      Fragment.__super__.layout.call(this);
      return this.diagram.popFragment();
    };

    Fragment.prototype.onDraw = function(context) {
      Fragment.__super__.onDraw.call(this, context);
      return this.diagram.drawBoxBasedLeft(this.margin, 0, this.text);
    };

    return Fragment;

  })(FragmentBase);

  TextParser = (function() {

    function TextParser(context) {
      this.diagram = new SequenceDiagram(context);
      this.factory = new CommandFactory();
    }

    TextParser.prototype.parse = function(text) {
      var cmd, cmdText, cmdTexts, state;
      cmdTexts = text.split('\n');
      state = new State(this.diagram, cmdTexts);
      while (state.hasNext()) {
        cmdText = state.next();
        cmd = this.factory.create(cmdText);
        if (cmd) {
          cmd.setup(cmdText);
          cmd.execute(state);
        }
      }
      return this.diagram;
    };

    return TextParser;

  })();

  State = (function() {

    function State(diagram, cmdTexts) {
      this.diagram = diagram;
      this.cmdTexts = cmdTexts;
      this.index = 0;
      this.stack = [];
      this.lines = {};
    }

    State.prototype.hasNext = function() {
      return this.index < this.cmdTexts.length;
    };

    State.prototype.next = function() {
      var cmdText;
      if (this.index < this.cmdTexts.length) {
        cmdText = this.cmdTexts[this.index];
        this.index++;
        return cmdText;
      }
    };

    State.prototype.line = function(name) {
      var line;
      line = this.lines[name];
      if (line) {
        return line;
      }
      line = new LifeLine(this.diagram, name);
      this.lines[name] = line;
      this.diagram.addLine(line);
      return line;
    };

    State.prototype.current = function() {
      if (this.stack.length === 0) {
        return this.diagram;
      }
      return this.stack[this.stack.length - 1];
    };

    return State;

  })();

  CommandFactory = (function() {

    function CommandFactory() {
      this.cmds = [];
      this.cmds.push(new AltCommand);
      this.cmds.push(new OptionCommand);
      this.cmds.push(new ElseCommand);
      this.cmds.push(new EndCommand);
      this.cmds.push(new NoteCommand);
      this.cmds.push(new MessageCommand);
      this.cmds.push(new ExecutionCommand);
    }

    CommandFactory.prototype.create = function(cmdText) {
      var cmd, _i, _len, _ref;
      _ref = this.cmds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cmd = _ref[_i];
        if (cmd.match(cmdText)) {
          return cmd;
        }
      }
    };

    return CommandFactory;

  })();

  Command = (function() {

    function Command() {}

    Command.prototype.setup = function(text) {
      var index, result, value, _i, _len, _results;
      result = this.match(text);
      _results = [];
      for (index = _i = 0, _len = result.length; _i < _len; index = ++_i) {
        value = result[index];
        if (value) {
          value = value.trim();
        }
        if (0 < index) {
          _results.push(this[this.names[index - 1]] = value);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Command.prototype.match = function(text) {
      return text.match(this.reg);
    };

    return Command;

  })();

  MessageCommand = (function(_super) {

    __extends(MessageCommand, _super);

    function MessageCommand() {
      return MessageCommand.__super__.constructor.apply(this, arguments);
    }

    MessageCommand.prototype.reg = /^\s*?([^\]>-]+)(\])?->([^\[:]+)(\[)?(?::(.*))?$/;

    MessageCommand.prototype.names = ["fromName", "isReply", "toName", "isSync", "text"];

    MessageCommand.prototype.execute = function(state) {
      var from, message, to;
      from = state.line(this.fromName);
      to = state.line(this.toName);
      if (this.isReply) {
        message = new ReplyMessage(state.diagram, this.text, from, to);
      } else if (this.isSync) {
        message = new SyncMessage(state.diagram, this.text, from, to);
      } else {
        message = new Message(state.diagram, this.text, from, to);
      }
      return state.current().addItem(message);
    };

    return MessageCommand;

  })(Command);

  NoteCommand = (function(_super) {

    __extends(NoteCommand, _super);

    function NoteCommand() {
      return NoteCommand.__super__.constructor.apply(this, arguments);
    }

    NoteCommand.prototype.reg = /^\s*(left|right|note|comment)@([^\:]+):(.*)$/i;

    NoteCommand.prototype.names = ["position", "lineName", "text"];

    NoteCommand.prototype.execute = function(state) {
      return state.current().addItem(new Note(state.diagram, this.text, state.line(this.lineName), this.position === "left"));
    };

    return NoteCommand;

  })(Command);

  ExecutionCommand = (function(_super) {

    __extends(ExecutionCommand, _super);

    function ExecutionCommand() {
      return ExecutionCommand.__super__.constructor.apply(this, arguments);
    }

    ExecutionCommand.prototype.reg = /^([^\[\]]+)(\[|\])$/;

    ExecutionCommand.prototype.names = ["lineName", "last"];

    ExecutionCommand.prototype.execute = function(state) {
      var item;
      if (this.last === '[') {
        item = new ExecutionStart(state.line(this.lineName));
      } else {
        item = new ExecutionEnd(state.line(this.lineName));
      }
      return state.current().addItem(item);
    };

    return ExecutionCommand;

  })(Command);

  OptionCommand = (function(_super) {

    __extends(OptionCommand, _super);

    function OptionCommand() {
      return OptionCommand.__super__.constructor.apply(this, arguments);
    }

    OptionCommand.prototype.reg = /^\s*(assert|break|consider|critical|ignore|loop|neg|opt|par|seq|strict)(?::(.*))?$/i;

    OptionCommand.prototype.names = ["type", "text"];

    OptionCommand.prototype.execute = function(state) {
      var frag;
      if (this.text) {
        frag = new Fragment(state.diagram, this.type + " [" + this.text + "]");
      } else {
        frag = new Fragment(state.diagram, this.type);
      }
      state.current().addItem(frag);
      return state.stack.push(frag);
    };

    return OptionCommand;

  })(Command);

  EndCommand = (function(_super) {

    __extends(EndCommand, _super);

    function EndCommand() {
      return EndCommand.__super__.constructor.apply(this, arguments);
    }

    EndCommand.prototype.reg = /^\s*end\s*$/i;

    EndCommand.prototype.names = [];

    EndCommand.prototype.execute = function(state) {
      return state.stack.pop();
    };

    return EndCommand;

  })(Command);

  AltCommand = (function(_super) {

    __extends(AltCommand, _super);

    function AltCommand() {
      return AltCommand.__super__.constructor.apply(this, arguments);
    }

    AltCommand.prototype.reg = /^\s*alt(?:\:(.*))?$/i;

    AltCommand.prototype.names = ["text"];

    AltCommand.prototype.execute = function(state) {
      var alt, guard;
      alt = new Alt(state.diagram, "alt");
      state.current().addItem(alt);
      guard = new Guard(state.diagram, this.text);
      state.stack.push(guard);
      return alt.addItem(guard);
    };

    return AltCommand;

  })(Command);

  ElseCommand = (function(_super) {

    __extends(ElseCommand, _super);

    function ElseCommand() {
      return ElseCommand.__super__.constructor.apply(this, arguments);
    }

    ElseCommand.prototype.reg = /^\s*else(?:\:(.*))?$/i;

    ElseCommand.prototype.names = ["text"];

    ElseCommand.prototype.execute = function(state) {
      var guard;
      guard = new Guard(state.diagram, this.text);
      state.current().parent.addItem(guard);
      state.stack.pop();
      return state.stack.push(guard);
    };

    return ElseCommand;

  })(Command);

  SeqJs = this.SeqJs = {};

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SeqJs;
  }

  SeqJs.version = '0.0.1';

  SeqJs.TextParser = TextParser;

}).call(this);
